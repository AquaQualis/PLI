/* atan.pli                                                          */
/*********************************************************************/
/*           Iron Spring PL/I Runtime Library Version 0.9.8          */
/*              Distributed under the Gnu LGPL License               */
/*                                                                   */
/*      Module:        _pli_ATAN, (PL/I runtime)                     */
/*      Version:       1.0                                           */
/*      Date:          Feb, 2015                                     */
/*      Author:        Peter Flass                                   */
/*                                                                   */
/*      Entry Points:  _pli_atan                                     */
/*                                                                   */
/*      Function:      Double precision atan and atand               */
/*                     (FLOAT BIN(49))                               */
/*                                                                   */
/*      Dependencies:                                                */
/*                   * Intel Floating point format (IEEE 754).       */
/*                   * Iron Spring PL/I 0.9.7 and above.             */
/*                   * The results are only accurate to the stated   */
/*                     precision.                                    */
/*                                                                   */
/*                     NOTE that the input and output are extended   */
/*                     precision, but the internal calculations      */
/*                     are all done in double precision.             */
/*                                                                   */
/*      Calling sequence:                                            */
/*                     DCL ATAN ENTRY( FIXED BIN(31),                */
/*                                     FLOAT BIN(52)                 */
/*                                  [ ,FLOAT BIN(52) ] )             */
/*                              RETURNS( FLOAT BIN(52) )             */
/*                              OPTIONS( LINKAGE(SYSTEM))            */
/*                              EXT( '_pli_ATAN' );                  */
/*                     res = ATAN(fun,arg1 [,arg2]);                 */
/*                       fun is fixed bin(31): 2=ATAN, 3=ATAND       */
/*                         corresponding two-arg versions 92 and 93. */
/*                       arg, arg2 are float bin(52) converted       */
/*                           if necessary by the caller.             */
/*                                                                   */
/*                     The one-argument version returns atan(arg1),  */
/*                     the two-argument version returns              */
/*                       atan(arg1/arg2)                             */
/*                                                                   */
/*      Output:                                                      */
/*                       res is float bin(52) returned in ST(0)      */
/*                                                                   */
/*      Called from:   Compiled code.                                */
/*                                                                   */
/*      Errors:        ?                                             */
/*                                                                   */
/*      To Do:                                                       */
/*                                                                   */
/*      Modifications:                                               */
/*                                                                   */
/*      Algorithm based on s_atan.c by Sun Microsystems.             */
/*                                                                   */
/*-------------------------------------------------------------------*/
/*                                                                   */
/* Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved. */
/*                                                                   */
/* Developed at SunSoft, a Sun Microsystems, Inc. business.          */
/* Permission to use, copy, modify, and distribute this              */
/* software is freely granted, provided that this notice             */
/* is preserved.                                                     */
/*                                                                   */
/* Method                                                            */
/*   1. Reduce x to positive by atan(x) = -atan(-x).                 */
/*   2. According to the integer k=4t+0.25 chopped, t=x, the argument*/
/*      is further reduced to one of the following intervals and the */
/*      arctangent of t is evaluated by the corresponding formula:   */
/*                                                                   */
/*      (0,7/16)      atan(x) = t-t^3*(a1+t^2*(a2+...(a10+t^2*a11)...*/
/*      (7/16,11/16)  atan(x) = atan(1/2) + atan( (t-0.5)/(1+t/2) )  */
/*      (11/16.19/16) atan(x) = atan( 1 ) + atan( (t-1)/(1+t) )      */
/*      (19/16,39/16) atan(x) = atan(3/2) + atan( (t-1.5)/(1+1.5t) ) */
/*      (39/16,INF)   atan(x) = atan(INF) + atan( -1/t )             */
/*                                                                   */
/*********************************************************************/

atan: proc(fun,arg1,arg2) returns( float bin(52) )
              options( linkage(system) )
              ext( '_pli_atan' );
	      
 /*-----------------------------------*/
 /*  Parameters                       */
 /*-----------------------------------*/
 dcl      fun                 fixed bin(31);
 dcl     (arg1,arg2)          float bin(52);
	      
 /*-----------------------------------*/
 /*  Static data                      */
 /*-----------------------------------*/
 /*
  * 
  * Constants:
  * The hexadecimal values are the intended ones for the following 
  * constants. The decimal values may be used, provided that the 
  * compiler will convert from decimal to binary accurately enough 
  * to produce the hexadecimal values shown.
  */
 dcl      atanhi         (0:3)float bin(49)  static    init(
  4.63647609000806093515e-01, /* atan(0.5)hi 0x3FDDAC67, 0x0561BB4F */
  7.85398163397448278999e-01, /* atan(1.0)hi 0x3FE921FB, 0x54442D18 */
  9.82793723247329054082e-01, /* atan(1.5)hi 0x3FEF730B, 0xD281F69B */
  1.57079632679489655800e+00  /* atan(inf)hi 0x3FF921FB, 0x54442D18 */
  );

 dcl      atanlo         (0:3)float bin(49)  static    init(
  2.26987774529616870924e-17, /* atan(0.5)lo 0x3C7A2B7F, 0x222F65E2 */
  3.06161699786838301793e-17, /* atan(1.0)lo 0x3C81A626, 0x33145C07 */
  1.39033110312309984516e-17, /* atan(1.5)lo 0x3C700788, 0x7AF0CBBD */
  6.12323399573676603587e-17  /* atan(inf)lo 0x3C91A626, 0x33145C07 */
  );
 dcl      aT            (0:10)float bin(49)  static    init(
  3.33333333333329318027e-01, /* 0x3FD55555, 0x5555550D */
 -1.99999999998764832476e-01, /* 0xBFC99999, 0x9998EBC4 */
  1.42857142725034663711e-01, /* 0x3FC24924, 0x920083FF */
 -1.11111104054623557880e-01, /* 0xBFBC71C6, 0xFE231671 */
  9.09088713343650656196e-02, /* 0x3FB745CD, 0xC54C206E */
 -7.69187620504482999495e-02, /* 0xBFB3B0F2, 0xAF749A6D */
  6.66107313738753120669e-02, /* 0x3FB10D66, 0xA0D03D51 */
 -5.83357013379057348645e-02, /* 0xBFADDE2D, 0x52DEFD9A */
  4.97687799461593236017e-02, /* 0x3FA97B4B, 0x24760DEB */
 -3.65315727442169155270e-02, /* 0xBFA2B444, 0x2C6A6C2F */
  1.62858201153657823623e-02  /* 0x3F90AD3A, 0xE322DA11 */
  );
     
 dcl      one                 float bin(49)  static    init(1e0);
 dcl      huge                float bin(49)  static    init(1e300);
 /* Conversion factor - radians to degrees */
 dcl      rd                  float bin(49)  static    
                    init(57.2957795131e0);
 
 /* The following are inline in the C code */
 dcl      x7fffffff           fixed bin(31)  static
              init( 2147483647 );
 dcl      x7ff00000           fixed bin(31)  static
              init( 2146435072 );
 dcl      x44100000           fixed bin(31)  static
              init( 1141899264 );
 dcl      x3fdc0000           fixed bin(31)  static
              init( 1071382528 );
 dcl      x3e200000           fixed bin(31)  static
              init( 1042284544 );
 dcl      x3ff30000           fixed bin(31)  static
              init( 1072889856 );
 dcl      x3fe60000           fixed bin(31)  static
              init( 1072037888 );
 dcl      x40038000           fixed bin(31)  static
              init( 1073971200 );

 /* Definition of 8-byte float        */
 dcl    1 flt                 based,
          2 flt_lo            fixed bin(31),
	  2 flt_hi            fixed bin(31);
 
 dcl     (IAND)               builtin;

 /*-----------------------------------*/
 /*  Automatic data                   */ 
 /*-----------------------------------*/
 dcl      x                   float bin(49);
 dcl     (w,s1,s2,z)          float bin(49);
 dcl     (ix,hx,id)           fixed bin(31);
 
 /* The following assignment may cause overflow if the argument      */
 /* exceeds the exponent range for a double.                         */
 if fun>10 then x = arg1/arg2;          /* Two-arg version           */
 else x = arg1;
 
 /* NOTE: To obtain the same results as C we should set FPCW         */

	hx = __HI(x); /* Upper word of a double as FIXED BIN(31)     */
        /*
             __HI(x)     the high part of a double x 
                     (sign,exponent,the first 21 significant bits)
             __LO(x)     the least 32 significant bits of x
        */	
	


        /* COMMENT: Error handling simplified to simply raise ERROR  */
	/*          in case of invalid argument.                     */
	ix = IAND(hx,x7fffffff);
	if ix>=x44100000  then do;	/* if |x| >= 2^66 */
	  if ix>x7ff00000 |
	    (ix=x7ff00000 & (__LO(x)^=0))
	  then signal ERROR;
 /*	  then return( x+x );		/* NaN */
   	  if hx>0 then return(  atanhi(3)+atanlo(3) );
   	  else         return( -atanhi(3)-atanlo(3) );
	  end;
        if ix < x3fdc0000 then do;	/* |x| < 0.4375 */
	  /* Argument is very small or zero */
	  if ix < x3e200000  		/* |x| < 2^-29 */
    	  then if huge+x>one then return( x ); /* raise inexact */
	  id = -1;
	  end;
	else do;
	  x = abs(x);
	  if ix < x3ff30000 then do;	/* |x| < 1.1875 */
	    if ix < x3fe60000 then do;	/* 7/16 <=|x|<11/16 */
	      id = 0; 
	      x = (2.0*x-one)/(2.0+x);
	      end;
	    else do; 
	      id = 1; 
	      x  = (x-one)/(x+one);
	      end; 
	    end;
        else do;	    
	    if (ix < x40038000) then do;/* |x| < 2.4375 */
	      id = 2; 
	      x  = (x-1.5)/(one+1.5*x);
	      end;
	    else do;  
	      id = 3; 
	      x  = -1.0/x;
	      end;
	    end;
	  end;  
    /* end of argument reduction */

	z = x*x;
	w = z*z;
    /* break sum from i=0 to 10 aT(i)z**(i+1) into odd and even poly */
	s1 = z*(aT(0)+w*(aT(2)+w*(aT(4)+w*(aT(6)+w*(aT(8)+w*aT(10))))));
	s2 = w*(aT(1)+w*(aT(3)+w*(aT(5)+w*(aT(7)+w*aT(9)))));
	if id<0 then return( raddeg(x - x*(s1+s2)) );
	else do;
	  z = atanhi(id) - ((x*(s1+s2) - atanlo(id)) - x);
	  if hx<0 then return( raddeg(-z) );/*return( (hx<0)? -z:z );*/
	  else         return( raddeg(z) );
	  end;
	  
 /* Return value in degrees or radians */
 raddeg: proc(x) returns( float bin(52) )
         options( linkage(system) );
  dcl     x                   float bin(49);	 
  if mod(fun,2)=0                       /* Radians                   */
  then return(x);
  else return(x*rd);                    /* Degrees                   */
  end raddeg;
	  
 __HI: proc(x) returns( fixed bin(31) );
   dcl    x                   float bin(49);
   return( addr(x)->flt_hi );	  
   end __HI;
	  
 __LO: proc(x) returns( fixed bin(31) );
   dcl    x                   float bin(49);
   return( addr(x)->flt_lo );	  
   end __LO;
   	  
  end atan;
