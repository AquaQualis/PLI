 /* PLITASK - PL/I Task interface                                    */
 /********************************************************************/
 /*           Iron Spring PL/I Runtime Library Version 0.9.1         */
 /*              Distributed under the Gnu LGPL License              */
 /*                                                                  */
 /*      Module:        PLITASK                                      */
 /*      Version:       1.0                                          */
 /*      Date:          April, 2010                                  */
 /*      Author:        Peter Flass                                  */
 /*                                                                  */
 /*      Function:      PLITASK is the PL/I TASK interface.          */
 /*                                                                  */
 /*      Entry Points:  PLITASK                                      */
 /*                                                                  */
 /*      Calling Sequence: (see below)                               */
 /*                                                                  */
 /*      Parameters:                                                 */
 /*                                                                  */
 /*      Description:                                                */
 /*          Iron Spring PL/I implements the PL/I for MVS and VM     */
 /*          multitasking functions.  PL/I(F) tasking is somewhat    */
 /*          different - all tasks are subtasks of a hidden "control */
 /*          task."  IBM Enterprise PL/I implements threading but    */
 /*          not multitasking - uses a different API.                */
 /*                                                                  */
 /*          All required information is passed to PLITASK in a      */
 /*          block called a 'TSB' (Task Startup Block) which is      */
 /*          created as a result of a CALL with the TASK, EVENT, or  */
 /*          PRIORITY options.  The TSB is located on the stack      */
 /*          above (higher addresses) any required dummy arguments   */
 /*          and the argument list.  The address of the TSB is       */
 /*          passed to PLITASK as the sole argument.  All data       */
 /*          between the argument and the start of the TSB is        */
 /*          moved to the new thread's stack as arguments to the     */
 /*          invoked procedure.  The stack layout looks like this:   */
 /*          (for PL/I linkage.)                                     */
 /*                                                                  */
 /*               |         TSB            |                         */
 /*               +------------------------+ <-+                     */
 /*               |                        |   |                     */
 /*               |    Dummy arguments     |   |                     */
 /*               |      and such          |   |                     */
 /*               +------------------------+   |                     */
 /*           +4  |    Argument list       |   |                     */
 /*               +------------------------+   |                     */
 /*           +0  |    Addr(TSB)           | --+                     */
 /*               +------------------------+                         */
 /*                                                                  */
 /*          The TSB contains the number of arguments and a flag     */
 /*          word indicating whether each argument points to data    */
 /*          or to a locator/descriptor pair.                        */
 /*                                                                  */
 /*          Following the move, the argument list is relocated      */
 /*          as necessary.  Procedures with SYSTEM linkage           */
 /*          don't require relocation.                               */
 /*           1. Each argument is an address.  If the address is     */
 /*              between the address of the TSB passed to PLITASK    */
 /*              and the start of the TSB itself then -              */
 /*           2. The address is relocated by the difference between  */
 /*              the address of the original argument list and       */
 /*              the new.                                            */
 /*           3. If the flags word indicates that this argument      */
 /*              points to a locator/descriptor and the address of   */
 /*              the loc/desc is in the relocated area, these        */
 /*              fields are processed like argument addresses.       */
 /*                                                                  */
 /*          TCBs are linked in the following structure:             */   
 /*                                                                  */
 /*             +---------+      (child->parent)                     */
 /*             | Initial |<------+----------------+                 */
 /*             +---------+       ^                ^                 */
 /*                 | ^           |                |                 */
 /*                 v |           |                |                 */
 /*             +---------+   +---------+     +---------+            */
 /*             | First   | ->| Next    | ...>| Last    |            */
 /*             | Child   |   | Sibling |     | Child   |            */
 /*             +---------+   +---------+     +---------+            */
 /*                 | ^          ...              ...                */
 /*                 v |                                              */
 /*             +---------+                                          */
 /*             | Child of|-> ...                                    */
 /*             |  Child  |                                          */
 /*             +---------+                                          */
 /*                ...                                               */
 /*                                                                  */
 /*      Structure:                                                  */
 /*      * PLITASK is the OS-dependent PL/I task interface used by   */
 /*        PL/I CALL TASK statement.                                 */
 /*                                                                  */
 /*        It does the synchronization and calls beginthread to      */
 /*        start the new thread. Procedure new_task in this module   */
 /*        runs in the new thread. It establishes the PL/I           */
 /*        environment and calls the user's TASK procedure.          */
 /*                                                                  */
 /*      * beginthread is the OS-dependent thread interface,         */
 /*        which may also be used (later) by the PL/I CALL THREAD    */
 /*        statement. It allocates and chains a thread control block */
 /*        (TCB) and the stack for the new thread.                   */
 /*                                                                  */
 /*      * beginthread calls OSCreateThread, which is the minimal    */
 /*        assembler code necessary to start a thread on the         */
 /*        current OS.                                               */
 /*                                                                  */
 /*      Dependencies:                                               */
 /*	     PLITASK uses the thread routine BeginThread.	     */
 /*                                                                  */
 /*      To Do:                                                      */
 /*                                                                  */
 /*      Modifications:                                              */
 /*                                                                  */
 /********************************************************************/

 PLITASK: package exports( pli_task, new_task );

 /*------------------------*/
 /* EXTERNAL data          */
 /*------------------------*/
 dcl	  thread_mutex	      fixed bin(31)  static    init(0)
              ext( '_pli_thread_mutex' );

 /*------------------------*/
 /* Prototypes             */
 /*------------------------*/
 dcl     PTR                 ptr                 based;
 dcl     FB15                fixed bin(15)       based;
 dcl     FB31                fixed bin(31)       based;
 dcl     EVENT		     event		 based;
 
 /*------------------------*/
 /* EXTERNAL entries       */
 /*------------------------*/
 dcl     GetTCB              entry(fixed bin(31))
                             external( '_pli_GetTCB' )
                             returns( ptr )
                             options( LINKAGE(SYSTEM) );
 dcl     BeginThread         entry( ptr,	  /* pfnThread       */
 				    ptr,	  /* ulArg	     */
				    ptr,	  /* pTask	     */
				    ptr,	  /* pEvent	     */
                                    bit(32),      /* ulFlags	     */
				    fixed bin(31),/* ulStackSize     */
				    fixed bin(31) ) /* ulPriority    */
                             external( '_pli_BeginThread' )
                             returns( ptr )          
                             options( LINKAGE(SYSTEM) );
 dcl	 mutex_wait	     entry(ptr)			     
			     options( LINKAGE(SYSTEM) )
			     external( '_pli_mutex_wait' );
 dcl	 mutex_post	     entry(ptr)			     
			     options( LINKAGE(SYSTEM) )
			     external( '_pli_mutex_post' );
 %replace SYS_KILL   by 37;
 %replace SIGKILL    by  9;
 dcl      syscall	     entry
 			     returns( fixed bin(31) )
			     options( asm linkage(system) )
			     ext( '_pli_Syscall' );

 dcl    (
         addr,
         allocate,
         auto,
         binvalue,
	 completion,
         entryaddr,
         heximage,
         null,
         plifill,
         plimove,
	 status,
         stg,
         sysnull
        )                    builtin;
 dcl     barrier             builtin;

 PLI_TASK: procedure(pTSB)
           ext( '_pli_Task' )
           options( linkage(system) );

 /*------------------------*/
 /* Parameters             */
 /*------------------------*/
 dcl     pTSB                ptr;           /* ->TSB                 */

 /*------------------------*/
 /* AUTOMATIC data         */
 /*------------------------*/
 dcl     rc                  fixed bin(31);
 dcl     pTCB		     ptr;
 dcl     thread_stack        fixed bin(31); /* Thread stack size     */
 dcl	 thread_start  	     event;	    /* Complete when started */
 dcl     p                   ptr;
	  
 /*-----------------------------------*/
 /* Beginning of procedure            */
 /*-----------------------------------*/
 p,pTSB->TSB_parent = GetTCB(0);        /* Current TCB address       */
 pTSB->TSB_pStart = addr(thread_start);
 completion(thread_start)='0'b;
 if (p->TCB_flags&'C0000000'bx)='00000000'bx then do;
   /*display( 'PLITASK: Can''t start thread' );*/
   signal error;
   end;
 if pTSB->TSB_pTask^=sysnull() then do;	/* Init TASK variable        */
   call plifill( pTSB->TSB_pTask, '00'x, stg(null()->TASK) );
   pTSB->TSB_pTask->TASK_priority = pTSB->TSB_priority;
   end;

 /*-----------------------------------*/
 /* Start the thread                  */
 /*-----------------------------------*/
 p = addr(pTSB); 
 thread_stack = 65536;  
 pTCB = BeginThread( entryaddr(new_task),	  /* pfnThread	     */
 		     p,				  /* ulArg	     */
		     pTSB->TSB_pTask,		  /* pTask	     */
		     pTSB->TSB_pEvent,    	  /* pEvent	     */
                     '00000000'bx, 		  /* Start active    */
		     thread_stack,  		  /* Stack size	     */
		     pTSB->TSB_priority );	  /* Thread priority */
		     
 if pTSB->TSB_pTask^=sysnull() 		/* Init TASK variable        */
 then pTSB->TSB_pTask->TASK_pTCB = pTCB;		     
 /*display( 'PLITASK: Waiting for task to start' );/**/
 wait( thread_start );                 	/* Wait for thread startup   */
 /*display( 'PLITASK: Wait complete' );            /**/
 /* The wait is complete when 'new_task' has initialized.	     */
 
 return;                               /* Return to caller           */

 end PLI_TASK;

 %page;

 /*------------------------------------------------------------------*/
 /* This is the startup procedure for the new thread.                */
 /* It runs as the first procedure with the new stack.               */
 /*------------------------------------------------------------------*/
 new_task: proc(ppTSB)
             options( fromalien linkage(system) )
             ext( '_pli_Subtsk' ); 
    
  /*------------------------*/
  /* Parameters             */
  /*------------------------*/
  dcl     ppTSB               ptr;           /* ->addr(pTSB)         */

  /*------------------------*/
  /* AUTOMATIC data         */
  /*------------------------*/
  dcl     pTSB                ptr;           /* ->TSB                */
  dcl     pTCB		      ptr;	     /* ->My TCB	     */
  dcl     pParent	      ptr;	     /* ->Parent TCB	     */
  dcl     rc                  fixed bin(31);
  dcl    (pArg,pTop)          ptr;
 
  dcl     arglist_size        fixed bin(31);
  dcl     reloc               fixed bin(31);
  dcl     i                   fixed bin(31);
  dcl    (p,q)                ptr;
  dcl	 task_complete        event;	     /* Task complete	     */
  dcl    thread_exit	      label;	     /* BeginThread exit     */

  /* 'real_entry' is declared as 'LINKAGE(SYSTEM)' regardless of     */
  /* the actual linkage type.					     */
  dcl     real_entry          entry variable
                              options( linkage(system) );

  /* display( 'PLITASK: Subtask started' );/**/
  pTCB = GetTCB(0);         		    /* Current TCB address   */
  pTSB = ppTSB->PTR;                        /* addr(TSB)             */
  thread_exit = pTCB->TCB_Exit;		    /* Save exit address     */
  pTCB->TCB_Exit = task_exit;		    /* Set new exit	     */
  pTCB->TCB_pComplete = addr(task_complete);/* ->Completion Event    */
  /* If this task has no children, there is nothing to wait for      */
  completion(task_complete)='1'b;

  /*-----------------------------------------------------------------*/
  /* Initialize TCB Task Chains                                      */
  /*-----------------------------------------------------------------*/
  pTCB->TCB_flags = '40000000'bx;	    /* Not initial task	     */
  pParent = pTSB->TSB_parent;    	    /* addr(parent TCB)      */
  pTCB->TCB_parent = pParent;		    /* Update par/child rel  */
  call mutex_wait( addr(thread_mutex) );   /* Lock the TCB structure */
  
  /* Force parent to wait for subtasks before terminating.           */
  completion(pParent->TCB_pComplete->EVENT)='0'b;
  pParent->TCB_flags = pParent->TCB_flags | '01'bx;
  if pParent->TCB_child^=sysnull then do;
    pTCB->TCB_sib = pParent->TCB_child;
    pParent->TCB_child = pTCB;
    end;
  else do;
    pParent->TCB_child = pTCB;
    end;
  call mutex_post( addr(thread_mutex) );/* Unlock TCB structure 0.9.2*/
 
 /*------------------------------------------------------------------*/
 /* Get stack storage and copy argument list for thread,             */
 /* as indicated in the TSB to the current stack.                    */
 /* Note that the AUTO [or AUTOMATIC] builtin is currently intended  */
 /* for internal use only.                                           */
 /*------------------------------------------------------------------*/
 arglist_size = pTSB - ppTSB;               /* Size of arglist       */
 pArg = auto(arglist_size);                 /* Get stack storage     */
 pTop = pArg + arglist_size;                /* Highest address       */
 reloc = ppTSB+4 - pArg;                    /* Relocation factor     */
 call plimove(pArg,ppTSB+4,arglist_size );  /* Move arglist          */

 /*------------------------------------------------------------------*/
 /* For PL/I linkage, relocate any addresses of dummy arguments or   */
 /* temporary descriptors.                                           */
 /*------------------------------------------------------------------*/
 if pTSB->TSB_PLI_linkage then do;          /* Do the relocations    */
   p = pArg;                                /* ->First argument      */
   do i=1 to pTSB->TSB_argcnt;
     if p->PTR > ppTSB & p->PTR < pTSB then do;
       call do_reloc(i,p);
       p = p + stg(null()->PTR);
       end; /* if */
     end; /* do i */
   end; /* PLI_linkage */
   
 /*------------------------------------------------------------------*/
 /* Call the invoked procedure, the (relocated) argument list is     */
 /* on top of the stack.                                             */
 /*------------------------------------------------------------------*/
 real_entry = pTSB->TSB_entryaddr;          /* Save entry address    */
 /*display( 'PLITASK: Posting task started' );/**/
 call barrier;                              /* Flush cache writes    */
 completion(pTSB->TSB_pStart->EVENT)='1'b;  /* Task started          */
 /*------ After this point the TSB will no longer be accessible -----*/
 
 call real_entry;                           /* Call the thread code  */
 
 /* Normal return from a task thread comes here.                     */
 /* Other-than-normal return will have already raised FINISH,        */
 /* and will be to 'task_exit'.                                      */
 signal finish;

 /*------------------------------------------------------------------*/
 /* The task returns here when it terminates.                        */
 /* Each child thread is sent a SIGKILL signal to terminate.         */
 /* (this may operate recursivly for lower levels of subtasks).      */
 /* Then wait until all subtasks complete.  If this task is the      */
 /* only (or only remaining) subtask of a parent, post the parent    */
 /* that all it's subtasks are complete.                             */
 /*------------------------------------------------------------------*/
 task_exit:
   /* display( 'PLITASK: task_exit for TCB ' || /**/
   /*             heximage(addr(pTCB),4) );     /**/
   
   /*-- LOCK ------- */
   call mutex_wait( addr(thread_mutex) );/* Lock the TCB structu0.9.2*/
   p = pTCB->TCB_child;
   do while( p^=sysnull );
     rc = SYSCALL( SYS_KILL, p->TCB_TID, SIGKILL );
     if rc^=0 
     then display( 'PLITASK: SYS_KILL (' || p->TCB_TID || ') rc=' || rc );
     p = p->TCB_sib;
     end; /* do while */
	       
   /* Unlink TCB from parent and sibling chains                      */
   if pParent->TCB_child = pTCB then do;/* Is this first child?	     */
     pParent->TCB_child  = pTCB->TCB_sib;/* Yes, just unlink	     */
     pTCB->TCB_sib = sysnull;		/* Just for luck	     */
     end; /* first child */
   else do;				/* No, locate on chain	     */
     p = pParent->TCB_child;
     do while('1'b );
       q = p->TCB_sib;
       if q=sysnull then signal error;  /* TCB not found	     */
       if q=pTCB then leave;		/* This is the TCB	     */
       p = q;				/* Otherwise chase chain     */
       end; /* do while */
     p->TCB_sib = pTCB->TCB_sib;
     pTCB->TCB_sib = sysnull;
     end; /* not first child */
   call mutex_post( addr(thread_mutex) );/* Unlock TCB structure0.9.2*/
   /*-- UNLOCK ---- */
   
   /* If this task has children, wait for them to terminate.         */
   /* display('PLITASK: Waiting for children' ); /**/
   wait(task_complete);
   /* display( 'PLITASK: Wait complete' ); /**/
    
   /*-- LOCK ------- */
   /* All subtasks of this one are now complete.                     */
   call mutex_wait( addr(thread_mutex) );/* Lock the TCB structu0.9.2*/
   /* If this is the last child of this parent, post parent.	     */
   if (pParent->TCB_flags&'01'bx)='00'bx
   then do;
     /* display( 'PLITASK: Last child complete' );/**/
     completion(pParent->TCB_pComplete->EVENT)='1'b;
     end;
   call mutex_post( addr(thread_mutex) );/* Unlock TCB structure0.9.2*/
   /*-- UNLOCK ----- */
   
   goto thread_exit;			/* Finish the thread	     */  
   /* 'thread_exit' does not return   */

  /*----------------------------------*/
  /* Relocate Argument List           */
  /*----------------------------------*/
  do_reloc: proc(n,pArg);
    dcl  n                   fixed bin(31);
    dcl  pArg                ptr;
    dcl  pNew                ptr;
    dcl  p                   ptr;
    pNew = pArg->PTR - reloc;
    pArg->PTR = pNew;
    if pTSB->tsb_arginfo(n) then do;    /* Loc/Desc         */
      if pNew->pData > ppTSB & pNew->pData < pTSB then do;
        p = pNew->pData - reloc;
        pNew->pData = p;
        end; /* loc */
      if pNew->pDesc > ppTSB & pNew->pDesc < pTSB then do;
        p = pNew->pDesc - reloc;
        pNew->pDesc = p;
        end; /* desc */
      end; /* loc/desc */
    end do_reloc;

 end new_task;

 %page;

 %include tsb;
 %include tcb;
 %include task;
 %include locdesc;
 %include entry;
 %include gbl;
 %include event;

 end PLITASK;                         /* End of package             */

