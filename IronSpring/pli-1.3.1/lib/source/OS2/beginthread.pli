 /* BeginThread - PL/I thread interface                              */
 /********************************************************************/
 /*           Iron Spring PL/I Runtime Library Version 0.9.2         */
 /*              Distributed under the Gnu LGPL License              */
 /*                                                                  */
 /*      Module:        BeginThread                                  */
 /*      Version:       1.0                                          */
 /*      Date:          October, 2010                                */
 /*      Author:        Peter Flass                                  */
 /*                                                                  */
 /*      Function:      This is the OS/2 version of BeginThread      */
 /*			code to create a thread.                     */
 /*			Calls: OSCreateThread.			     */
 /*                                                                  */
 /*                     It is mostly common with the Linux version,  */
 /*                     except that it establishes the exception     */
 /*                     handler for the new thread and terminates    */
 /*                     the thread with a call to DosExit.           */
 /*                                                                  */
 /*      Entry Points:  _pli_Thrd                                    */
 /*                                                                  */
 /*      Calling Sequence: (see below)                               */
 /*                                                                  */
 /*      Parameters:                                                 */
 /*                                                                  */
 /*      Description:                                                */
 /*                                                                  */
 /*      Dependencies:                                               */
 /*                                                                  */
 /*      To Do:                                                      */
 /*	      * The thread procedure is a 'LIMITED ENTRY' (4 bytes)  */
 /*		but we currently have no way to specify this, so we  */
 /*		play games using PTR.  This needs to be fixed.       */
 /*                                                                  */
 /*      Modifications:                                              */
 /*                                                                  */
 /********************************************************************/

BeginThrd: package exports( BeginThread );

 /*------------------------*/
 /* EXTERNAL data          */
 /*------------------------*/
 dcl	  thread_mutex	      fixed bin(31)  static    init(0)
              ext( '_pli_thread_mutex' );

 /*------------------------*/
 /* STATIC data            */
 /*------------------------*/

 /*------------------------*/
 /* Prototypes             */
 /*------------------------*/
 dcl      EVENT               event     based;
 
 /*------------------------*/
 /* EXTERNAL entries       */
 /*------------------------*/
 dcl     OSCreateThread       entry( ptr,   	    /* pfnFunction   */
 			 	     ptr,           /* ulArg         */
 			 	     fixed bin(31), /* ulStackSize   */
 			 	     bit(32),	    /* ulFlags 	     */	
 			 	     ptr )          /* pulStackAddr  */
			     returns( fixed bin(31) )
			     ext( '_pli_OSCreateThread' )
			     options( LINKAGE(SYSTEM) );		     		
 dcl     getgbl              entry     
                             returns( ptr )          
			     options( LINKAGE(SYSTEM) )
			     external( '_pli_GetGbl' );       			     
 dcl     getdsa              entry     
                             returns( ptr )          
			     options( LINKAGE(SYSTEM) )
			     external( '_pli_GetDSA' );
 dcl     GetProcInfo         entry( ptr )
                             returns( fixed bin(31) )
                             external( '_pli_OSGetProcInfo' )
                             options( LINKAGE(SYSTEM) );

 dcl     mutex_init          entry(ptr,fixed bin(31))         /*0.9.3*/
                             options( linkage(system) )
                             ext( '_pli_mutex_init' );
 dcl     mutex_wait          entry(ptr)              
                             options( linkage(system) )
                             ext( '_pli_mutex_wait' );
 dcl     mutex_post          entry(ptr)              
                             options( linkage(system) )
                             ext( '_pli_mutex_post' );
 dcl     DosSetExceptionHandler
                           entry( ptr )			/* pERegRec */
                             returns( fixed bin(31) /*unsigned*/ )
                             options( asm linkage(system) )
                             external( 'DosSetExceptionHandler' );
 dcl     trap              entry 
                           external( '_pli_Trap' );
 dcl     exit              entry 
                           external( '_pli_Exit' );

 dcl    ( 
         addr,	         
	 binvalue,
	 completion,
         cs,
	 entryaddr,      
         heximage,
         null,
         plifill,
	 plifree,
	 status,
         stg,
         sysnull
        )                    builtin;

 dcl     barrier             builtin;
 %page;	
	  

BeginThread: proc(pfnThread,ulArg,pTask,pEvent,
	          ulFlags,ulStackSize,ulPriority)
 	      returns(ptr)
	      options( LINKAGE(SYSTEM) )
              ext( '_pli_BeginThread' );

 /*------------------------*/
 /* Parameters             */
 /*------------------------*/
 dcl	 pfnThread   	     ptr;            /* Thread proc          */
 dcl	 ulArg		     fixed bin(31);  /* Thread argument      */
 dcl     pTask		     ptr;	     /* ->TASK variable	     */
 dcl     pEvent		     ptr;	     /* ->EVENT variable     */
 dcl     ulFlags             bit(32);        /* Thread flags         */
         /* '01000000'bx: Start thread suspended                     */
 dcl     ulStackSize         fixed bin(31);  /* Thread stack size    */	 
 dcl     ulPriority          fixed bin(31);  /* Thread priority      */	 

 /*------------------------*/
 /* AUTOMATIC data         */
 /*------------------------*/
 dcl     rc                  fixed bin(31);
 dcl     thread_stack_size   fixed bin(31); /* Rounded stack size    */
 dcl     pTCB                ptr;           /* ->New TCB             */
 dcl	 pDSA		     ptr;	    /* ->My DSA		     */
 dcl     callers_chc	     ptr;	    /* Caller's ON-unit chain*/
 dcl     p 		     ptr;
 
 /*------------------------------------*/
 /* Initialize error handler           */
 /*------------------------------------*/
 if thread_mutex=0 then do;
   call mutex_init( addr(thread_mutex), 0 );                  /*0.9.3*/
   end;
 pTCB = sysnull();
 /* Magic -- clear caller's established ON-Units and then establish  */
 /* a new one for ERROR.					     */
 pDSA = getdsa();
 pDSA = pDSA - stg( null()->dsa_below_ebp );
 callers_chc = pDSA->dsa_chc;		/* Save on-unit chain	     */	
 pDSA->dsa_chc = sysnull();
 /*on error goto cleanup;*/
 
 /*------------------------------------*/
 /* Create the TCB                     */
 /*------------------------------------*/
 allocate TCB set(pTCB);
 call plifill( pTCB, '00'x, stg(pTCB->TCB) );
 pTCB->TCB_entry = pfnThread;		/* Save real entry address   */
 pTCB->TCB_arg   = ulArg;		/*  and argument	     */
 pTCB->TCB_priority = ulPriority;	/* Thread priority	     */
 pTCB->TCB_pEvent = pEvent;		/* Save EVENT variable addr  */
 if pEvent^=sysnull()			/* Initialize event var.     */
 then call plifill( pEvent, '00'x, stg(null()->EVENT) );
 
 /* Round requested stack size         */
 thread_stack_size = (ulStackSize + 4095) / 4096;
 thread_stack_size = thread_stack_size * 4096;
 
 /*------------------------------------*/
 /* Create New Thread                  */
 /*------------------------------------*/
 p = entryaddr(startup);
 rc = OSCreateThread( p,             		/* +08 */
 		      pTCB, 			/* +0C */
		      thread_stack_size,	/* +10 */
		      ulFlags,      		/* +14 */
		      addr(pTCB->TCB_stack) );  /* +18 */
 if rc<=0 then goto cleanup;	        /* Error on create           */
 pTCB->TCB_tid = rc;
 if pTask^=sysnull then do;		/* Update task variable	     */
   pTask->TASK_pTCB = pTCB;
   end;
     
 /*------------------------------------*/
 /* Exit                               */
 /*------------------------------------*/
 pDSA->dsa_chc = callers_chc;		/* Restore on-unit chain     */
 call barrier;
 return(pTCB);           
     
 /*------------------------------------*/
 /* Error Handler                      */
 /*------------------------------------*/
 cleanup:
 /*display( 'BEGINTHREAD: Thread cleanup for TCB ' || /**/
 /*            heximage(addr(pTCB),4) );              /**/
 if pTCB^=sysnull() then do;
   if pTCB->TCB_stack^=sysnull		/* Free allocated stack      */
   then call plifree(pTCB->TCB_stack);
   free pTCB->TCB;			/* Free allocated TCB        */
   end;
 pDSA->dsa_chc = callers_chc;		/* Restore on-unit chain     */
 signal error;				/* Resignal error	     */	

 end BeginThread;                  	/* End of procedure          */
     
 /*------------------------------------------------------------------*/
 /* Startup procedure for new thread				     */
 /* This is the root procedure for the thread.           	     */
 /*------------------------------------------------------------------*/
 startup: proc(pTCB) 
	  options( FROMALIEN LINKAGE(SYSTEM) )
          ext( '_pli_Thrd' );	  
   dcl   pTCB                ptr;           /* ->New TCB             */
   dcl	 pDSA		     ptr;	    /* ->My DSA		     */
   dcl   pCh		     ptr;
   dcl   pEv		     ptr;
   dcl   rc                  fixed bin(31);
   dcl   real_entry	     entry variable
   			     options( LINKAGE(SYSTEM) );
   dcl 1 ERegRec,
         5 prev_structure    ptr,
	 5 ExceptionHandler  ptr,
	 5 attn_ONCB_chain   ptr;            /* PL/I extension       */ 			     
	  
   /*display( 'BEGINTHREAD: Startup TCB ' || heximage(addr(pTCB),4) );/**/
   /* Establish the thread's exception handler.                      */
   pDSA = GetDSA();                    /* pDSA->My EBP               */
   pDSA = pDSA - stg( sysnull()->dsa_below_ebp );
   pDSA->dsa_chc = sysnull;            /* Clear ONCB chain           */   
   ERegRec.prev_structure   = sysnull();
   ERegRec.ExceptionHandler = entryaddr(trap);
   ERegRec.attn_ONCB_chain  = sysnull();
   RC = DosSetExceptionHandler( addr(ERegRec) );
   if RC^=0 then signal ERROR;
   addr(real_entry)->ent_entry_point = pTCB->TCB_entry;
   pTCB->TCB_Exit = thread_exit;
   pTCB->TCB_pEREGREC = addr( ERegRec );/* ->Excpt Reg Rec           */   

   call mutex_wait( addr(thread_mutex) );/* Lock the TCB chain       */ 
   pCh = getgbl();			/* Get addr(global_data)     */
   pTCB->TCB_next = pCh->GBL_TCB_anchor;/* Chain this TCB	     */
   pCh->GBL_TCB_anchor = pTCB;  
   call mutex_post( addr(thread_mutex) );/* Unlock the TCB chain     */ 
   /* COMMENT: At this point the new thread could be either a thread */
   /*	     or a task, so it's only linked onto the common chain.   */
   /*          If it's a task, the task chains will be updated later.*/

   call barrier;
   call real_entry(pTCB->TCB_arg);
     
 /*------------------------------------------------------------------*/
 /* Normal exit from thread                                          */
 /* Normal return from FINISH ON-Unit or return from thread proc.    */
 /*------------------------------------------------------------------*/
 thread_exit: 
   /*display( 'BEGINTHREAD: Thread exit' ); /**/
   /* Post caller's event complete */
   pEv = pTCB->TCB_pEvent;
   if pEv^=sysnull then do;
     status(pEv->EVENT) = pTCB->TCB_status;
     completion(pEv->EVENT)='1'b;
     end;
   call mutex_wait ( addr(thread_mutex) );/* Lock the TCB chain     */ 
   pCh = getgbl();			/* Get addr(global_data)    */
   if pCh->GBL_TCB_anchor = pTCB	/* Unchain this TCB	    */
   then pCh->GBL_TCB_anchor = pTCB->TCB_next;
   else do;
     pCh = pCh->GBL_TCB_anchor;
     do while(pCh^=sysnull);
       if pCh->TCB_next = pTCB then leave;
       pCh = pCh->TCB_next;
       end; /* do while */
     end;
   if pCh^=sysnull 
   then pCh->TCB_next = pTCB->TCB_next;
   /* If this is last thread of thread 1, post thread 1 complete    */
   pCh = getgbl();			/* Get addr(global_data)    */
   pCh = pCh->GBL_TCB_anchor;           /* Thread 1 TCB             */
   if pCH->TCB_next = sysnull           /* Last thread?             */
   then completion( pCh->TCB_pComplete->EVENT )='1'b;

   call mutex_post ( addr(thread_mutex) );/* Unlock the TCB chain   */ 
   /*display( 'BEGINTHREAD: terminating TCB ' || /**/
   /*              heximage(addr(pTCB),4) );     /**/
   call exit;	 
	  
   end startup;
%page;   

 %include tcb;
 %include gbl;
 %include entry;
 %include dsa;
 %include event;
 %include task;

 end BeginThrd;                    /* End of package             */
