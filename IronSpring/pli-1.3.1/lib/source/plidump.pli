 /* _pli_Dump                                                        */
 /********************************************************************/
 /*           Iron Spring PL/I Runtime Library Version 0.5           */
 /*              Distributed under the Gnu LGPL License              */
 /*                                                                  */
 /*      Module:        PLIDump (PL/I runtime)                       */
 /*      Version:       1.0                                          */
 /*      Date:          May, 2004                                    */
 /*      Author:        Peter Flass                                  */
 /*                                                                  */
 /*      Entry Points:  _pli_Dump                                    */
 /*                                                                  */
 /*      Function:      PLIDUMP builtin subroutine.                  */
 /*                                                                  */
 /*      Reference:     SC26-3113-01, pp.386-388.                    */
 /*                                                                  */
 /*      Dependencices: Stack Frame format.                          */
 /*                     Requires the standard data of EBP and EIP    */
 /*                     at 0[EBP] and 4[EBP] respectively.  A PL/I   */
 /*                     stack frame is recognized by -4[EBP]         */
 /*                     containing the address of the PGT.  If found */
 /*                     the entry-point address is assumed to be     */
 /*                     at -10'x[EBP].                               */
 /*                                                                  */
 /*      Called From:   CALL PLIDUMP() statement.                    */
 /*                                                                  */
 /*      Calling sequence:                                           */
 /*                     CALL PLIDUMP( 'opt_string', 'title_string' );*/
 /*                     opt_string: character expression consisting  */
 /*                     of one or more of the following:             */
 /*                         A - display information on all threads   */
 /*                         B - hexadecimal dump of control blocks   */
 /*                         C - continue after dump                  */
 /*                         E - exit current thread                  */
 /*                         F - print file information               */
 /*                         H - HEX storage dump (not implemented)   */
 /*                        NB - no control block information         */
 /*                        NF - no file information                  */
 /*                        NH - no storage dump (ignored)            */
 /*                        NT - no traceback                         */
 /*                         O - only current thread information      */
 /*                         S - stop after dump                      */
 /*                         T - traceback                            */
 /*                     Default is 'TFC' if not specified.           */
 /*                     title_string: character expression used      */
 /*                     as dump title.                               */
 /*                                                                  */
 /*      To Do:                                                      */
 /*                                                                  */
 /*                                                                  */
 /*      Modifications:                                              */
 /*          2012-09-06: Fix ABEND in some FROMALIEN entries.   0.9.4*/
 /*          2009-12-14: Replace WriteLn with display.           0.8c*/
 /*                                                                  */
 /********************************************************************/

 pli_Dump: proc( option_string, title_string )
           external( '_pli_Dump' );

 /*-------------------------*/
 /* Parameters              */
 /*-------------------------*/
 dcl     option_string       char(*)   varying;
 dcl     title_string        char(*)   varying;

 /*-------------------------*/
 /* Automatic Storage       */
 /*-------------------------*/
 dcl     option_flag      (8)bit(1);
         /* option_flag(1): A - Dump all tasks                      */
         /* option_flag(2): B - Hexadecimal dump                    */
         /* option_flag(3): C - Continue after dump                 */
         /* option_flag(4): E - Exit current task after dump        */
         /* option_flag(5): F - Dump file information               */
         /* option_flag(6): O - Dump only current task              */
         /* option_flag(7): S - Stop after dump                     */
         /* option_flag(8): T - Traceback                           */
 dcl     not                 bit(1)    init( '0'b );
 dcl     is_PLI              bit(1)    init( '1'b );         /*0.9.4*/
 dcl     c                   char(1);
 dcl     EBP                 ptr;
 dcl     prior_ebp           ptr;
 dcl     pDSA                ptr;
 dcl     line                char(80) varying;
 dcl    (ent_off,ent_addr,ret_addr)
                             char(8);
 dcl     my_edi              ptr;
 dcl     epp                 ptr;
 dcl     eip                 ptr;
 dcl     char4               char(4);
 dcl     i                   fixed bin(15);
 dcl     j                   fixed bin(7);

 /*-------------------------*/
 /* Static Storage          */
 /*-------------------------*/
 dcl     option_chars        character(18)       static
                   init( 'abcefostnABCEFOSTN' );

 dcl     conds            (9)char(6)   static    var  init(
         'CONV ',  'FOFL ',  'OFL ',  'SIZE ',  'STRG ',
         'STRZ ',  'SUBRG ', 'UFL ',  'ZDIV ' );

 /*-------------------------*/
 /* Templates               */
 /*-------------------------*/
 dcl     ep_len              fixed bin(7)   based(epp);
 dcl     ep_name             char(128)      based(epp);
 dcl     ptr                 ptr            based;
 dcl     dword               ptr            based;
 dcl     VarStr              char(0)   var  based;
 dcl     c4                  char(4)        based;

 /*-------------------------*/
 /* External Entries        */
 /*-------------------------*/
 dcl     GetDSA              entry
                             external( '_pli_GetDSA' )
                             returns( ptr )
                             options( LINKAGE(SYSTEM) );
 dcl     XDump               entry( ptr )
                             external( '_pli_XDump' );

 dcl    (addr,heximage,null,stg,string,substr)                 /*0.8c*/
                             builtin;

 /*------------------------------------------------------------------*/
 /*      Parse Option String                                         */
 /*------------------------------------------------------------------*/
 on error begin;                       /* Handle errors         0.9.4*/
   display( 'Error -- PLIDUMP terminated' );                  /*0.9.4*/
   goto notrace;                       /* Return or stop        0.9.4*/
   end;                                                       /*0.9.4*/
   
 /* Options:           'ABCEFOST'                                    */
 string(option_flag) = '00101001'b;    /* Set default options - CFT  */
 do i=1 to length(option_string);      /* Parse option_string        */
   c = substr(option_string,i,1);      /* Get next character         */
   j = index( option_chars, c );       /* Get option index           */
   if jª=0 then do;                    /* Zero=unrecognized option   */
     if j>9 then j=j-9;                /* Fold upper-case            */
     if j=9 then not='1'b;             /* 'N'                        */
     else do;                          /* Else set option bit        */
       if not then option_flag(j)='0'b;
       else        option_flag(j)='1'b;
       not='0'b;                       /* Reset 'N' after option     */
       end;
     end; /* jª=0 */
   else not='0'b;                      /* Reset 'N' for invalid opt  */
   end; /* do i */
 if option_flag(2)                     /* 'B' implies 'T'            */
 then option_flag(8) = '1'b;

 /*------------------------------------------------------------------*/
 /*      Print Dump Title                                            */
 /*------------------------------------------------------------------*/
 display( title_string );
 display( '' );

 EBP = GetDSA();                       /* Get addr(my_stack_frame)   */
 pDSA = EBP - stg( null()->dsa_below_ebp );
 my_edi = pDSA->dsa_edi;               /* addr(PGT) for checking     */
 prior_ebp = addr(pDSA->dsa_ebp);      /* Caller's EBP               */

 /*------------------------------------------------------------------*/
 /*      Walk back DSA chain and print                               */
 /*------------------------------------------------------------------*/
 if ªoption_flag(8) then goto notrace; /* No traceback               */

 display( 'Address  Caller   Entry name' );
 trace: do while( '1'b );
   if is_PLI='0'b then leave trace;              /* FROMALIEN   0.9.4*/
   /* A PL/I procedure will have EDI->PGT                            */
   if pDSA->dsa_edi ª= my_edi then do;           /* Non-PL/I routine */
     is_PLI='0'b;
     line = (18)' ' || 'Non-PL/I procedure';
     display( line );
     display( ' ' );                                          /*0.9.2*/
     /* At this point we should dump the unformatted stack frame.    */
     end; /* non-PL/I */
   else do;                                      /* PL/I routine     */
     is_PLI='1'b;
     /* We *COULD* verify that the instruction at the entry point is */
     /* 'CALL DWORD PTR 0[EDI]'.  This is 'FF17'x, but would best be */
     /* checked by comparing to the two bytes at my entry point.     */
     /* We *SHOULD* verify that the length is greater than zero and  */
     /* less than some reasonable value: max_length_ext_label = 64.  */
     epp = pDSA->dsa_epa;                        /* Entry point addr */
     char4 = bsw( addr(epp) );
     ent_addr = heximage( addr(char4), 4 );
     eip = pDSA->dsa_eip;                        /* Entry point addr */
     epp = epp-1;                                /* -> Length of name*/
     j = ep_len;                                 /* Save length      */
     epp = epp-j;                                /* -> Text of name  */
     char4 = bsw( addr(eip) );
     line = ent_addr || ' ' || heximage( addr(char4), 4 ) || ' ' ||
            substr(ep_name,1,j);
     display( line );
     if option_flag(2) then call print_DSA(pDSA);
     if substr(ep_name,1,j)='_pli_Init'          /* End of chain     */
     then leave trace;
     if substr(ep_name,1,j)='_pli_Thrd'          /* End of chain0.9.2*/
     then leave trace;					      /*0.9.2*/
    end; /* PL/I */
   prior_ebp = addr(pDSA->dsa_ebp);    /* Caller's EBP               */
   EBP = pDSA->dsa_ebp;                /* Back up in stack           */
   pDSA = EBP - stg( null()->dsa_below_ebp );    /* -> Stack frame   */
   end trace;

 notrace: ;
   if option_flag(7) then stop;        /* 'T' - terminate            */

 /*------------------------------------------------------------------*/
 /*      Print DSA Information                                       */
 /*      ebp is the value of EBP for the following stack frame       */
 /*------------------------------------------------------------------*/
 print_DSA: proc(pDSA);
   dcl   pDSA                ptr;      /* DSA Address                */
   dcl   fp                  ptr;      /* This frame                 */
   dcl   char4               char(4);
   dcl   line                char(80) varying;
   dcl   i                   fixed bin(31);
   dcl   n                   fixed bin(31);
   dcl  (p,q)                ptr;
   dcl   mask            (16)bit(1);

   if option_flag(2) then do;          /* If 'B' print storage       */
     display( ' ' );
     /* Hex dump of temporaries       */
     p = prior_ebp+stg(null->dsa_above_ebp);
     char4 = bsw( addr(p) );           /* DSA address                */
     line = 'Temporaries at ' || heximage(addr(char4),4);
     display( line );
     call hexdump( p, pDSA->dsa_bos, 0 );

     /* Hex dump of user data         */
     char4 = bsw( addr(pDSA->dsa_bos) ); /* Start of user data       */
     line = 'Data at ' || heximage(addr(char4),4);
     display( line );
     call hexdump( pDSA->dsa_bos, addr(pDSA->dsa_bos),
                   pDSA->dsa_bos-addr(pDSA->dsa_ebp) );

     end; /* 'B' */

   char4 = bsw( addr(pDSA) );          /* Print DSA address          */
   line = 'DSA at ' || heximage(addr(char4),4);
   display( line );
   string(mask) = pDSA->dsa_msk;       /* Dump condition mask        */
   line = 'Enabled: ';
   do i=1 to hbound(conds,1);
     if mask(i) then line = line || conds(i);
     end;
   display( line );
   if mask(14) then do;                                       /*0.9.4*/
     display( 'FROMALIEN' );                                  /*0.9.3*/
     is_PLI='0'b;                                             /*0.9.4*/
     end;                                                     /*0.9.4*/
   if mask(15) then display( 'On-Unit DSA' );
   if mask(16) then display( 'Library Procedure' );
   if ªoption_flag(2)                  /* If 'NB', then exit         */
   then return;

   /* Hex dump of standard DSA        */
   call hexdump( pDSA, addr(pDSA->dsa_parm),
                 pDSA-addr(pDSA->dsa_ebp) );

   /* Trap Parameters                 */
   if substr(ep_name,1,9) = '_pli_Trap' then do;
     call XDump( addr(pDSA->DSA_parm) );
     end; /* trap */

   end print_DSA;

 return;

 /*------------------------------------------------------------------*/
 /*      Hex dump of a specified area                                */
 /*------------------------------------------------------------------*/
 hexdump: proc(from,to,offset);
   dcl  (from,to)            ptr;
   dcl   offset              fixed bin(31);
   dcl  (p,q)                ptr;
   dcl  (i,n,o)              fixed bin(31);
   dcl   dmask               char(80)  static    var  init(
       ( 'xxxxxxxx ( xxxxxx)                                     |'
         || (17)' ') );

   p = from;                           /* Starting address           */
   o = offset;                         /* Starting offset            */
   q = addr(line) + 56 +               /* ->Char output area         */
       stg(null()->VarStr);
   n = 20;
   do while( p<to );
     if n=20 then do;                  /* Plug address info          */
       line = dmask;                   /* Initialize dump line       */
       char4 = bsw( addr(p) );         /* Address                    */
       substr(line,1,8) = heximage(addr(char4),4);
       i = o;                          /* Offset (+|-)               */
       if i<0 then i=-i;
       char4 = bsw( addr(i) );
       substr(line,12,6)= heximage(addr(char4)+1,3);
       if o<0 then substr(line,11,1)='-';
       end;
     substr(line,n,8) = heximage(p,8); /* Data, no byte swapping     */
     q->c4 = xlt(p->c4);               /* Four 4-byte dwords         */
     n = n+9;
     q = q+4;
     if n>54 then do;
       substr(q->c4,1,1)='|';
       display( line );
       q = addr(line) + 56 +
           stg(null()->VarStr);
       substr(q->c4,1,17)='';
       n = 20;
       end; /* n */
     p = p+stg(p->dword);
     o = o+stg(p->dword);
     end; /* do while */
   if n>20 then do;
     substr(q->c4,1,1)='|';
     display( line );
     end;
   display( '' );
   end hexdump;

 /*------------------------------------------------------------------*/
 /*      Swap byte-order for display                                 */
 /*------------------------------------------------------------------*/
 bsw: proc(p) returns( char(4) );
   dcl   p                   ptr;
   dcl   cx               (4)char(1)   based(p);
   dcl   cy               (4)char(1);
   cy(4) = cx(1);            /* OR cy = reverse(cx)                  */
   cy(1) = cx(4);
   cy(3) = cx(2);
   cy(2) = cx(3);
   return( string(cy) );
   end bsw;

 /*------------------------------------------------------------------*/
 /*      Translate characters to printable                           */
 /*------------------------------------------------------------------*/
 xlt: proc(c4) returns( char(4) );
   dcl   c4                  char(4);
   dcl   c4x                 char(4);
   dcl   i                   fixed bin(7);
   c4x = c4;
   do i=1 to 4;
     if substr(c4x,i,1)<' ' |
        (substr(c4x,i,1)>byte(126) &                         /*0.9.10*/
         substr(c4x,i,1)ª=byte(172))
     then substr(c4x,i,1)='.';
     end;
   return( c4x );
   end xlt;

 %include DSA;

 end pli_Dump;
